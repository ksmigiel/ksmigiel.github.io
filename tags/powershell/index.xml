<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Powershell on </title>
    <link>http://ksmigiel.com/tags/powershell/</link>
    <description>Recent content in Powershell on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 28 Jan 2016 21:59:09 +0100</lastBuildDate>
    <atom:link href="http://ksmigiel.com/tags/powershell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Czy Windows może zastąpić Linuxa?</title>
      <link>http://ksmigiel.com/2016/01/powershell</link>
      <pubDate>Thu, 28 Jan 2016 21:59:09 +0100</pubDate>
      
      <guid>http://ksmigiel.com/2016/01/powershell</guid>
      <description>

&lt;p&gt;Lata temu przeżywałem okres fascynacji Linuxem. Pierwszą dystrybucją, którą zainstalowałem bodajże z 5 płyt CD był &lt;strong&gt;Mandrake Linux&lt;/strong&gt; (kontynuowany jako &lt;a href=&#34;https://pl.wikipedia.org/wiki/Mandriva_Linux&#34;&gt;Mandriva&lt;/a&gt; - obecnie nie jest już utrzymywana). Potem, o ile mnie pamięć nie myli, był Slackware i Slax (jego mniejszy kuzyn-portable).&lt;/p&gt;

&lt;h2 id=&#34;linuxy-i-konsola:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;Linuxy i konsola&lt;/h2&gt;

&lt;p&gt;Bardzo lubiłem dystrybucje &lt;a href=&#34;https://pl.wikipedia.org/wiki/Live_CD&#34;&gt;&lt;strong&gt;Live CD&lt;/strong&gt;&lt;/a&gt;. Wszystko zaczęło się, gdy popsułem bootloadera z instalacją Windows XP i przez kilka dni w domu nikt nie mógł używać komputera (no poza mną - linuksiarzem). Mieliśmy wtedy tylko jeden komputer (jakiś AMD Duron 800 Mhz), więc rodzina szybko wywarła na mnie wpływ i posprzątałem po sobie formatując cały dysk twardy, razem ze swoją świętą instalacją Linuxa. Nie chcąc w przyszłości psuć domownikom partycji z systemem operacyjnym, zacząłem szukać &amp;ldquo;bezpieczniejszych&amp;rdquo; alternatyw.&lt;/p&gt;

&lt;p&gt;Plusem systemów Live CD było to, że nie wymagały instalacji. Całość ładowana była do pamięci RAM, tak więc zaraz po włożeniu płytki mieliśmy w pełni działającego Linuxa. Problemem było zapisywanie swojej pracy i stanu systemu, jednak wspomniany Slax potrafił robić &amp;ldquo;snapshoty&amp;rdquo; i poprzez definicję modułów startowych, jakie miały zostać załadowane przy następnym rozruchu, mogliśmy bez problemu wznowić poprzednią sesję.&lt;/p&gt;

&lt;p&gt;Ale wiecie co? Ciągłe wkładanie i wyciąganie tej płyty w cale nie było takie wygodne. Poszedłem więc o krok dalej w tworzeniu swojego idealnego środowiska i złamałem wszelkie zasady ładując dystrybucję Live CD z dysku twardego do pamięci. Dla domowników cała operacja była transparentna, bo na dyskietce miałem bootloadera &lt;a href=&#34;http://lilo.alioth.debian.org/&#34;&gt;lilo&lt;/a&gt; ze Slax&amp;rsquo;em. Zatem udało mi się zamienić płytę na dyskietkę. Tak. Szczerze, nie wiem co mną wtedy kierowało, ale jak tego dokonałem znajdziecie w poście, który napisałem &lt;a href=&#34;http://sysios.blogspot.com/2006/02/linux-z-pyty.html&#34;&gt;&lt;strong&gt;10 lat&lt;/strong&gt; temu!&lt;/a&gt; W rzeczywistości wtedy zaczęła się moja przygoda z pisaniem (i na szczęście szybko się skończyła :D).&lt;/p&gt;

&lt;h3 id=&#34;konsola:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;Konsola!&lt;/h3&gt;

&lt;p&gt;Wszystkiemu winna była konsola. Wklepywanie komand w terminalu sprawiało mi tyle przyjemności, że po pewnym czasie w ogóle przestałem używać GUI (KDE, Gnome) i myszy. Koajrzycie &lt;a href=&#34;http://ekg.chmurka.net/&#34;&gt;EKG&lt;/a&gt; (&lt;strong&gt;E&lt;/strong&gt;ksperymentalny &lt;strong&gt;K&lt;/strong&gt;lient &lt;strong&gt;G&lt;/strong&gt;adu-Gadu)? To był dopiero hardkor. Poza surfowaniem po necie wszystko robiłem z poziomu terminala:, IRC, bash, python, vim i to poczucie &amp;ldquo;hakowania&amp;rdquo; było uzależniające.&lt;/p&gt;

&lt;h3 id=&#34;zawodowy-windows:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;Zawodowy Windows!&lt;/h3&gt;

&lt;p&gt;Po okresie &amp;ldquo;trybu tekstowego&amp;rdquo; wróciłem do normalności i Windowsa, na którym był większy wybór narzędzi do obróbki audio i edycji nut (jak wiecie zajmuje się tym w tak zwanym &amp;ldquo;międzyczasie&amp;rdquo;). Na początku przełączałem się między systemami, w zależności od tego co w danej chwili było mi potrzebne. Z czasem jednak godziny spędzane na Windowsie zaczęły przeważać i swoje &amp;ldquo;hakersko&amp;rdquo;-programistyczne nawyki zacząłem też tam przenosić. Poznałem platformę .NET, C#, VB. Na studiach wszystkie projekty pisałem w C# i w tym kierunku poprowadziłem swoją karierę. Związałem się zawodowo z Windowsem i chcąć nie chcąc musiałem zacząć szukać narzędzi, które wypełniłyby lukę po terminalu z Linuxa.&lt;/p&gt;

&lt;h2 id=&#34;posh-zastępca-basha:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;posh - zastępca basha&lt;/h2&gt;

&lt;p&gt;posh (&lt;strong&gt;P&lt;/strong&gt;ower&lt;strong&gt;Sh&lt;/strong&gt;ell) okazał się kapitalnym zamiennikiem. Nie dość, że mogłem ponownie klepać sobie komendy z terminala (nawet nazywające się tak samo, ale o tym zaraz), to świetnie sprawdził się jako pomoc w automatycji zadań, a jego integracja z .NET dostarczała ogromne możliwości eksperymentowania z punktu widzenia programisty. Serio, jeśli jeszcze nie korzystałeś z PowerShella w inny sposób, niż jak z &amp;ldquo;linii komend&amp;rdquo; i zamiennika &lt;code&gt;cmd.exe&lt;/code&gt;, koniecznie poświęc mu trochę czasu. Taka znajomość zaprocentuje. Mam nadzieję, że bardzo szybki przegląd ciekawostek posh&amp;rsquo;a zachęci Cię do poznania tej &amp;ldquo;linuxowej części windowsa&amp;rdquo; :)&lt;/p&gt;

&lt;h3 id=&#34;cmdlet-i-alias:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;cmdlet i alias&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;cmdlet&lt;/strong&gt; jest jakby .NET&amp;rsquo;owym obudowaniem zwykłego polecenia. Powrzechnie jest przyjęte nazywać je zgodnie ze schematem &lt;em&gt;Czasownik-Rzeczownik&lt;/em&gt;, np. &lt;code&gt;Get-Location&lt;/code&gt;. Wspominałem wyżej o takich samych nazwach komend, odpowiednikach Linuxowych: w rzeczywistości są to &lt;strong&gt;aliasy&lt;/strong&gt; do innych cmdletów.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;alias&lt;/th&gt;
&lt;th&gt;cmdlet&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;td&gt;Get-Location&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ls&lt;/td&gt;
&lt;td&gt;Get-ChildItem&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd&lt;/td&gt;
&lt;td&gt;Set-Location&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ps&lt;/td&gt;
&lt;td&gt;Get-Process&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mv&lt;/td&gt;
&lt;td&gt;Move-Item&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cp&lt;/td&gt;
&lt;td&gt;Copy-Item&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;man&lt;/td&gt;
&lt;td&gt;help&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rm&lt;/td&gt;
&lt;td&gt;Remove-Item&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cat&lt;/td&gt;
&lt;td&gt;Get-Content&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;grep&lt;/td&gt;
&lt;td&gt;Select-String&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;kill&lt;/td&gt;
&lt;td&gt;Stop-Process&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Dla niezaznajomionych z terminologią basha jego odpowiedniki w posh&amp;rsquo;u z pewnością okażą się bardziej intuicyjne i łatwiejsze w przyswojeniu.
Do identyfkowania aliasów i cmdletów służy &lt;code&gt;Get-Alias&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;PS&amp;gt; Get-Alias cd

CommandType     Name
-----------     ----
Alias           cd -&amp;gt; Set-Location

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oraz w przeciwnym kierunku, dostępne aliasy dla cmdleta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;PS&amp;gt; Get-Alias -Definition Get-Location

CommandType     Name
-----------     ----
Alias           gl -&amp;gt; Get-Location
Alias           pwd -&amp;gt; Get-Location

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zwróćię uwagę na &lt;code&gt;-Definition&lt;/code&gt;. Praktycznie każdy cmdlet akceptuje jeden lub więcej opcjonalnych parametrów, które po poleceniu poprzedzamy średnikiem (&lt;em&gt;-NazwaParametru Wartość&lt;/em&gt;). &lt;code&gt;Get-Help&lt;/code&gt; i MSDN będą niezastąpionymi źródłami wiedzy na ten temat. Możemy jednak szybko przeskanować interesujący nas cmdlet/obiekt.&lt;/p&gt;

&lt;h3 id=&#34;psobjet:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;&amp;lt;psobjet&amp;gt;&lt;/h3&gt;

&lt;p&gt;Wiedząc już, że polecenia są opakowane w obiekty, możemy zaglądnąc do &amp;ldquo;bebchów&amp;rdquo; każdego z nich.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;PS&amp;gt; Get-Alias | Get-Member

   TypeName: System.Management.Automation.AliasInfo

Name                MemberType     Definition
----                ----------     ----------
Equals              Method         bool Equals(System.Object obj)
GetHashCode         Method         int GetHashCode()
GetType             Method         type GetType()
ToString            Method         string ToString()
Definition          Property       string Definition {get;}
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jak widzicie mamy tutaj wgląd w strukturę całego obiektu, jego metody, właściwości. Przydaje się to szczególnie wtedy, gdy chcemy szybko rzucić okiem na dany cmdlet bez zagłębiania się w dokumentację, która z resztą jest całkiem opasła.&lt;/p&gt;

&lt;h3 id=&#34;operator-pipy:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;Operator pipy&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&amp;rdquo;|&amp;rdquo;&lt;/strong&gt;, czyli tzw. &lt;em&gt;pipeline operator&lt;/em&gt; pozwala na przekazywanie wyniku danego wywołania do kolejnego bez potrzeby rozdzielania go na osobne deklaracje etc. Bardzo popularna technika stosowana m.in w językach funkcyjnych (&amp;ldquo;|&amp;gt;&amp;rdquo; z F#). Powyżej przekazaliśmy &lt;code&gt;&amp;lt;psobjet&amp;gt; Get-Alias&lt;/code&gt; do &lt;code&gt;Get-Member&lt;/code&gt;, który (jak zaglądniecie do środka) przyjmuje paramter &lt;code&gt;[-InputObject &amp;lt;psobject&amp;gt;]&lt;/code&gt;. W ten sposób wiemy, że możemy korzystać z pipeline&amp;rsquo;a. Zwróćie też uwagę na &lt;code&gt;TypeName: System.Management.Automation.AliasInfo&lt;/code&gt; - jak widać nie kłamałem z tym .NET&amp;rsquo;em w środku posha :)&lt;/p&gt;

&lt;h3 id=&#34;filtrowanie-i-formatowanie:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;Filtrowanie i formatowanie&lt;/h3&gt;

&lt;p&gt;W pudełku z PS&amp;rsquo;em znajdziemy zestaw narzędzi umożliwiających w przystępny sposób formatowanie wyniku końcowego naszego polecenia/skryptu. Powiedzmy, że chcę listę pierwszych 10-ciu procesów i wynik ten dostać w postaci JSON. Brzmi skomplikowanie? Jak najbardziej! Tylko szkoda, że rozwiązanie jest trywialne:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;PS&amp;gt; ps | select Name, Id -First 10 | ConvertTo-Json

[
    {
        &amp;quot;Name&amp;quot;:  &amp;quot;ApplicationFrameHost&amp;quot;,
        &amp;quot;Id&amp;quot;:  4244
    },
    {
        &amp;quot;Name&amp;quot;:  &amp;quot;AudioDevMon&amp;quot;,
        &amp;quot;Id&amp;quot;:  2124
    },
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Albo tylko procesy Chrome?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;PS&amp;gt; ps | where ProcessName -eq chrome

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id  SI ProcessName
-------  ------    -----      ----- -----   ------     --  -- -----------
    287      26    55452      83712   315     3,16   2804   1 chrome
   1661      56   109428     144816   461   438,73   4232   1 chrome
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Z przyzwyczajenia używam możliwie najnowszej składni (PowerShell 5.0). W starszych wersjach wyglądałoby to nieco inaczej:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Get-Process | Where-Object { $_.ProcessName -eq &amp;quot;chrome&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jako ciekawostę polecam sprawdzić co robi &lt;code&gt;Out-GridView&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;użycie-net:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;Użycie .NET&lt;/h3&gt;

&lt;p&gt;Do metod &lt;code&gt;&amp;lt;psobject&amp;gt;&lt;/code&gt; możemy dobrać się na dwa sposoby:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# Bezpośrednio
(Get-Alias).GetType()

# Poprzez przypisanie
$alias = Get-Alias
$alias.GetType()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tworzenie obiektów .NET też trudne nie jest:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$random = New-Object -TypeName System.Random
$random.Next()
# 1168874665 - serio przepisałem to z terminala i zapewniam losowość :D
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;przydatne-skróty:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;Przydatne skróty&lt;/h3&gt;

&lt;p&gt;Na koniec jeszcze o paru wspomagaczach umilających pracę z poshem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ctrl + space&lt;/code&gt; przy operowaniu z obiektami .NET działa jako autocompleter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tab&lt;/code&gt; podpowiada parametry i property cmdletów.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f7 lub ↑/↓&lt;/code&gt; historia poleceń (niestety ładny bufor z f7 został usunięty w win10).&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.computerperformance.co.uk/powershell/powershell3_ise.htm&#34;&gt;PowerShell ISE&lt;/a&gt; - mały edytor z kolorowaniem składni i wbudowaną dokumentacją. Dostarczany w zestawie z poshem.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pushd/popd&lt;/code&gt; jako zamiennik &lt;code&gt;cd&lt;/code&gt;. Pozwala wrócić do poprzedniej lokacji. Można sobie oaliasować np. &lt;code&gt;cd/dc&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;windows-zlinuksiał:8c67b377fe66f9eab5dd926e008c6d14&#34;&gt;Windows &amp;ldquo;zlinuksiał&amp;rdquo;?&lt;/h2&gt;

&lt;p&gt;To pytanie zadane jest raczej w celu humorystycznym, choć Windowsowi w ostatnim czasie przybyło wiele cech, które mogłbyby pomóc w znalezieniu na nie odpowiedzi. Menedżery pakietów &lt;a href=&#34;https://chocolatey.org/&#34;&gt;Chocolatey&lt;/a&gt; i &lt;a href=&#34;http://www.hanselman.com/blog/AptGetForWindowsOneGetAndChocolateyOnWindows10.aspx&#34;&gt;OneGet&lt;/a&gt; (dostarczany w Win10) będące odpowiednikiem &lt;code&gt;apt-get&lt;/code&gt; i wiele repozytoriów open-source do złudzenia przypominają ekosystem Linuxa. Dla mnie bomba! Bo czuję się jak ryba w wodzie.&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://pl.wikipedia.org/wiki/Mandriva_Linux&#34;&gt;https://pl.wikipedia.org/wiki/Mandriva_Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pl.wikipedia.org/wiki/Live_CD&#34;&gt;https://pl.wikipedia.org/wiki/Live_CD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sysios.blogspot.com/2006/02/linux-z-pyty.html&#34;&gt;http://sysios.blogspot.com/2006/02/linux-z-pyty.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lilo.alioth.debian.org/&#34;&gt;http://lilo.alioth.debian.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ekg.chmurka.net/&#34;&gt;http://ekg.chmurka.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.computerperformance.co.uk/powershell/powershell3_ise.htm&#34;&gt;http://www.computerperformance.co.uk/powershell/powershell3_ise.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chocolatey.org/&#34;&gt;https://chocolatey.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hanselman.com/blog/AptGetForWindowsOneGetAndChocolateyOnWindows10.aspx&#34;&gt;http://www.hanselman.com/blog/AptGetForWindowsOneGetAndChocolateyOnWindows10.aspx&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>