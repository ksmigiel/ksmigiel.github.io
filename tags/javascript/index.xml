<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on </title>
    <link>http://ksmigiel.com/tags/javascript/</link>
    <description>Recent content in Javascript on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 11 Jun 2016 11:59:09 +0100</lastBuildDate>
    <atom:link href="http://ksmigiel.com/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Filtry Blooma</title>
      <link>http://ksmigiel.com/2016/06/bloom-filters</link>
      <pubDate>Sat, 11 Jun 2016 11:59:09 +0100</pubDate>
      
      <guid>http://ksmigiel.com/2016/06/bloom-filters</guid>
      <description>

&lt;p&gt;Dzisiaj będzie trochę bardziej nisko poziomowo (nie mylić z niższym poziomem posta). Postaram się w przystepny sposób przybliżyć wam czym jest Filtr Blooma i jak można go zaimplementować w JavaScripcie.&lt;/p&gt;

&lt;h2 id=&#34;filtra-teorie:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;Filtra teorie&lt;/h2&gt;

&lt;p&gt;Filtr Blooma to struktura danych pozwalająca w sposób szybki i pamięciowo optymalny odpowiedzieć na pytanie, czy dany element znajduje się w zbiorze. Niestety, ponieważ nie ma nic za darmo, za wydajność musimy zapłacić, a zapłatą będzie błąd w jaki struktura może nas wprowadzić. Nie użyłem &lt;strong&gt;probabilistyczna&lt;/strong&gt; bez powodu: filtr może stwierdzić jedynie, że elementu &lt;strong&gt;na pewno nie ma&lt;/strong&gt;, lub &lt;strong&gt;może jest&lt;/strong&gt; w zbiorze. Założenie to prowadzi do wniosków tzw. &lt;strong&gt;false-positive&lt;/strong&gt;, czyli że dany element nie istnieje w zadanym zbiorze, a jednak otrzymamy informację o jego prawdopodobnym istnieniu.&lt;/p&gt;

&lt;h3 id=&#34;budowa-i-parametry-filtra:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;Budowa i parametry filtra&lt;/h3&gt;

&lt;p&gt;Filtr można opisać mniej więcej tak:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Filtr Blooma to &lt;strong&gt;tablica&lt;/strong&gt; (wektor) &lt;em&gt;m&lt;/em&gt;-bitów, który ma &amp;ldquo;przewidywać&amp;rdquo; istnienie &lt;em&gt;n&lt;/em&gt; elementów. Elementy te zostały zakodowane &lt;em&gt;k&lt;/em&gt; funkcjami haszującymi.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Dobór tych parametrów wpływa na prawdopodobieństwo wystąpienia błędu (które chcemy minimalizować). &lt;a href=&#34;https://en.wikipedia.org/wiki/Bloom_filter&#34;&gt;Wikipedia&lt;/a&gt; bardzo ładnie przedstawia to od matematycznej strony. Najważniejsze są dwa wzory:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wikimedia.org/api/rest_v1/media/math/render/svg/76ffa4de74f3857f41900292d0fc315170cec674&#34; alt=&#34;k&#34; /&gt;
&lt;img src=&#34;https://wikimedia.org/api/rest_v1/media/math/render/svg/25b30f6928fac097a6e25aa7b7870a7722b7aea0&#34; alt=&#34;m&#34; /&gt;&lt;/p&gt;

&lt;p&gt;My do teorii aż tak wagi przywiązywać nie będziemy, ale trzeba pamiętać, że przy produkcyjnym użyciu takiej struktury bez wstępnej analizy się nie obejdzie.&lt;/p&gt;

&lt;h3 id=&#34;działanie-filtra:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;Działanie filtra&lt;/h3&gt;

&lt;p&gt;Całość sprowadza się do testu, czy dany bit (lub &lt;em&gt;k&lt;/em&gt; bitów w przypadku &lt;em&gt;k &amp;gt; 1&lt;/em&gt;) dla zadanej wartości (np. &lt;em&gt;x&lt;/em&gt;) jest zapalonych w tablicy. Jeśli choć jeden nie jest - mamy pewność, że element jest nieobecny.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/Bloom_filter.svg/649px-Bloom_filter.svg.png&#34; alt=&#34;bloom&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;haszowanie:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;Haszowanie&lt;/h3&gt;

&lt;p&gt;Orłem z kryptografii nie jestem, ale wyczytałem, że użyte funkcje haszujące powinny być przede wszystkim &lt;strong&gt;niezależne&lt;/strong&gt; i o &lt;strong&gt;jednostajnym rozkładzie prawdopodobieństwa&lt;/strong&gt;, np. takie jak: &lt;a href=&#34;https://sites.google.com/site/murmurhash/&#34;&gt;murmur&lt;/a&gt; lub &lt;a href=&#34;https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function&#34;&gt;fnv&lt;/a&gt;. Zalecam dalszą lekturę w tym zakresie dla zainteresowanych szczegółami.&lt;/p&gt;

&lt;h4 id=&#34;podwójne-haszowanie:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;Podwójne haszowanie&lt;/h4&gt;

&lt;p&gt;Jak i jakich funkcji używać do haszowania? Aby zapewnić prawdopodobieństwo błędu na podobnym poziomie, możemy skorzystać z &lt;a href=&#34;http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=4060353E67A356EF9528D2C57C064F5A?doi=10.1.1.152.579&amp;amp;rep=rep1&amp;amp;type=pdf&#34;&gt;&lt;strong&gt;podwójnego haszowania&lt;/strong&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://en.wikipedia.org/api/rest_v1/media/math/render/svg/64111088b311219da1c0bc477bf1d97ee0c42b69&#34; alt=&#34;double hash&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Będziemy potrzebować wtedy jedynie dwóch funkcji haszujących &lt;em&gt;h&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; i  &lt;em&gt;h&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;i&lt;/em&gt; - numer funkcji (nasze k), &lt;em&gt;T&lt;/em&gt; (nasze m). (&lt;em&gt;Przepraszam za zamieszanie z parametrami, ale wzory są żywcem z Wikipedii&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Myślę, że powoli możemy przejść do kodu i próby zaimplementowania tego wszystkiego, co wyżej opisałem.&lt;/p&gt;

&lt;h2 id=&#34;implementacja:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;Implementacja&lt;/h2&gt;

&lt;p&gt;Dla celów edukacyjnych przyjmijmy następujące parametry:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;k = 1    Jedna funkcja haszująca fnv-1
m = 16   16-bitowa tablica
n = 2    Dwa elementy
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fnv-1:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;fnv-1&lt;/h3&gt;

&lt;p&gt;Wybrałem tę, bo jest relatywnie prosta w implementacji:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Operacje na bitach w JS są 32-bitowe
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators
//
// Stałe dla 32-bitów
// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param
const FNV_OFFSET = 0x811c9dc5;
const FNV_PRIME = 0x01000193;

function fnv1(string) {
  let bytes = stringToBytes(string);
  let hash = FNV_OFFSET;

  for (let byte of bytes) {
    hash = hash * FNV_PRIME;
    hash = hash ^ byte;
  }

  return Math.abs(hash);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stringtobytes:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;stringToBytes&lt;/h3&gt;

&lt;p&gt;Powyższa funkcja potrzebuje tablicy bajtów z ciągu znaków. JS nie posiada takiej ładnej funkcji jak chociażby C# &lt;code&gt;byte[] bytes = encoding.GetBytes(AnyString)&lt;/code&gt;, dlatego musimy napisać coś podobnego. Dla ułatwienia przyjmijmy, że ciąg znaków kodowany jest w ASCII (basic English).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function stringToBytes(string) {
  let bytes = [];

  for (let char of string) {
    bytes.push(char.charCodeAt(0));
  }
  
  return bytes;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bloomfilter:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;BloomFilter&lt;/h3&gt;

&lt;p&gt;Jak zauważyliście używam składni ES6, o co by iść z duchem czasu. Filtr będzie przyjmował w konstruktorze liczbę bitów oraz funkcje haszujące, których chcemy użyć.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class BloomFilter {
  constructor (m, k) {
    this.bits = m;
    this.hashFunctions = k;
    this.filter = new Int32Array(m);
  }

  add (value) {
    for (let hash of this.hashFunctions) {
      let hashIndex = hash(value) % this.bits;
      this.filter[hashIndex] = 1;
    }
  }

  check (value) {
    for (let hash of this.hashFunctions) {
      let hashIndex = hash(value) % this.bits;
      if (this.filter[hashIndex] == 0)
        return false;
    }
    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testujemy:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;Testujemy!&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var bloomFilter = new BloomFilter(16, [ fnv1 ]);

bloomFilter.add(&#39;testujemy!&#39;);
bloomFilter.add(&#39;filtr&#39;);

bloomFilter.check(&#39;testujemy!&#39;);
// true
bloomFilter.check(&#39;filtr&#39;);
// true
bloomFilter.check(&#39;nie ma&#39;)
// false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prawdopodobieństwo błędu dla przyjętych parametrów wynosi:
&lt;img src=&#34;https://www4c.wolframalpha.com/Calculate/MSP/MSP772420gih62f6ech2f05000010ahiefh16dba6cd?MSPStoreType=image/gif&amp;amp;s=59&#34; alt=&#34;bloom&#34; /&gt;
&lt;em&gt;p ~= 0.12&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ale przy 10-ciu elementach wzrasta do &lt;em&gt;p ~= 0.46&lt;/em&gt;, dlatego dobór odpowiednich parametrów jest bardzo ważny.&lt;/p&gt;

&lt;h2 id=&#34;produkcyjne-użycia:15fbb8d9ed16407d5b96391271a178aa&#34;&gt;Produkcyjne użycia&lt;/h2&gt;

&lt;p&gt;Z Filtrów Blooma korzystają m.in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cassandra.apache.org/&#34;&gt;Cassandra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hadoop.apache.org/&#34;&gt;Hadoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/bigtable/&#34;&gt;Google BigTable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.akamai.com/&#34;&gt;Akamai&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Bloom_filter&#34;&gt;https://en.wikipedia.org/wiki/Bloom_filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sites.google.com/site/murmurhash/&#34;&gt;https://sites.google.com/site/murmurhash/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function&#34;&gt;https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param&#34;&gt;http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=4060353E67A356EF9528D2C57C064F5A?doi=10.1.1.152.579&amp;amp;rep=rep1&amp;amp;type=pdf&#34;&gt;http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=4060353E67A356EF9528D2C57C064F5A?doi=10.1.1.152.579&amp;amp;rep=rep1&amp;amp;type=pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Kontekst i &#39;this&#39; w JavaScripcie</title>
      <link>http://ksmigiel.com/2016/03/js-this</link>
      <pubDate>Wed, 30 Mar 2016 21:59:09 +0100</pubDate>
      
      <guid>http://ksmigiel.com/2016/03/js-this</guid>
      <description>

&lt;p&gt;Słówko &lt;code&gt;this&lt;/code&gt;, mimo podobieństwa do C# czy Javy, w JavaScripcie działa trochę inaczej niż nam się może wydawać. Kontekst na jaki wskazuje &lt;em&gt;this&lt;/em&gt; może być dowolnie zmieniany, a jego nieumiejętne użycie spowodowuje wystąpienie masy błędów w naszej aplikacji. Ustrzec przed nimi można się jedynie rozumiejąc do czego owe &lt;em&gt;this&lt;/em&gt; służy i jak się z nim obchodzić. Zapraszam do lektury :)&lt;/p&gt;

&lt;h2 id=&#34;implicit-binding:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;Implicit binding&lt;/h2&gt;

&lt;p&gt;Mamy tutaj do czynienia z kontekstem zwykłych obiektów. Złota zasada w identyfikacji kontekstu to:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;this&lt;/strong&gt; to obiekt, który jest po lewej stronie kropki.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;W myśl powyższej zasady możemy stwierdzić, że kontekstem funkcji &lt;code&gt;meow()&lt;/code&gt; będzie obiekt &lt;code&gt;cat&lt;/code&gt; i tak też się dzieje.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var cat = {
  name: &#39;Filemon&#39;,
  meow: function () {
    console.log(this.name);
  }
}

cat.meow();
// Filemon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podobnie sprawa ma się w przypadku zagdnieżdżonych obiektów i ich funkcji. Najbliższy obiekt po lewej stronie (z reguły, ale o tym zaraz) jest kontekstem, w jakim zostaje wywołana dana funkcja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var cat = {
  name: &#39;Filemon&#39;,
  brother: {
    name: &#39;Mruczek&#39;,
    meow: function () {
      console.log(this.name)
    }
  },
  meow: function () {
    console.log(this.name);
  }
}

cat.meow();
// Filemon

cat.brother.meow();
// Mruczek
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trzeba być bardzo ostrożnym jeśli chodzi o referencje do obiektów czy funkcji, gdyż takie przypisanie również powoduje zmianę kontekstu. Jest nim nadal &lt;em&gt;cat (Filemon)&lt;/em&gt;, a nie jakby można było sądzić &lt;em&gt;brother (Mruczek)&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;cat.meow = cat.brother.meow;
cat.meow();
// Filemon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Istnieją jednak sposoby na całkowie przejęcie kontroli nad tym co ma być w danej chwili &amp;ldquo;bazą&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;explicit-binding:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;Explicit binding&lt;/h2&gt;

&lt;p&gt;Oprócz operowania obiektami i zasadą &amp;ldquo;kropki&amp;rdquo; istnieją inne metody (pewne 3 funkcje), które pozwalają na zmianę kontekstu wywołania dowolnej funkcji.&lt;/p&gt;

&lt;h3 id=&#34;call:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;call()&lt;/h3&gt;

&lt;p&gt;Pozwala na wywołanie funkcji z konkretnym kontekstem przekazanym jako argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var meow = function () {
  console.log(&#39;I am a cat &#39; + this.name);
};

var filemon = {
  name: &#39;Filemon&#39;
};

var mruczek = {
  name: &#39;Mruczek&#39;
};

meow.call(filemon);
// I am a cat Filemon

meow.call(mruczek);
// I am a cat Mruczek

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bind:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;bind()&lt;/h3&gt;

&lt;p&gt;Jest to bardzo podobna funkcja do &lt;code&gt;call()&lt;/code&gt; z tą różnicą, że pozwala na &amp;ldquo;przechowanie&amp;rdquo; funkcji z nowym kontekstem w postaci zmiennej, aby móc ją na przykład przekazać dalej jako parametr funkcji.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var meow = function () {
  console.log(&#39;I am a cat &#39; + this.name);
};

var filemon = {
  name: &#39;Filemon&#39;
};

var mruczek = {
  name: &#39;Mruczek&#39;
};

var filemonMeow = meow.bind(filemon);
filemonMeow();
// I am a cat Filemon

var mruczekMeow = meow.bind(mruczek);
mruczekMeow()
// I am a cat Mruczek

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;apply:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;apply()&lt;/h3&gt;

&lt;p&gt;To taki helper składający tablicę w argumenty funkcji, który również jako parametr przyjmuje nowy obiekt, a ten stanie się &lt;em&gt;this&lt;/em&gt; w tej właśnie funkcji.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myCats = function (cat1, cat2) {
  console.log(&#39;I am &#39; + this.name + &#39; and my cats are: &#39; + cat1 + &#39; and &#39; + cat2);
};

var me = {
  name: &#39;Krzysztof&#39;
};

var cats = [&#39;Filemon&#39;, &#39;Mruczek&#39;];

myCats.apply(me, cats);
// I am Krzysztof and my cats are: Filemon and Mruczek
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;new-binding:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;New binding&lt;/h2&gt;

&lt;p&gt;Dochodzimy w końcu do momentu, z którym większość będzie najbardziej zaznajomiona, czyli konstruktory i keyword &lt;code&gt;new&lt;/code&gt;. Sytuacja jest tu o tyle prosta, że to &lt;em&gt;new&lt;/em&gt; nadaje kontekst całego obiektu podczas jego tworzenia.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Cat(name, color) {
  this.name = name;
  this.color = color;
  this.sayHello = function () {
    console.log(&#39;Hi, I am &#39; + name + &#39; colored &#39; + color);
  };
}

var filemon = new Cat(&#39;Filemon&#39;, &#39;black&#39;);
filemon.sayHello();
// Hi, I am Filemon colored black
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zwróćcie uwagę na &lt;strong&gt;brak&lt;/strong&gt; &lt;em&gt;this&lt;/em&gt; w wywołaniu funkcji &lt;code&gt;sayHello()&lt;/code&gt;. W każdym wypadku jego użycie jest opcjonalne. Domyślnie interpreter zawsze będzie wywoływał funkcję w kontekście rozwiązanym zgodnie z zasadami, które tu dzisiaj opisałem. Dla czytelności jednak lepiej jest użyć kontekstu, aby czarno na biało było widać co z czego jest wywoływane.
Spójrzcie na przykład bardziej zawiły, gdzie gdyby nie osobna referencja do obiektu macierzystego, odwołanie się do jego własności byłoby niemożliwe.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Cat(name, color) {
  var self = this;
  
  self.name = name;
  self.color = color;
  self.sayHello = function () {
    console.log(&#39;Hi, I am &#39; + self.name + &#39; colored &#39; + self.color);
  };
  
  self.brother = {
    name: &#39;Mruczek&#39;,
    sayHello: function () {
      console.log(&#39;Hi, I am &#39; + this.name + &#39; and my brother is &#39; + self.name);
    }
  };
}

var filemon = new Cat(&#39;Filemon&#39;, &#39;black&#39;);
filemon.sayHello();
// Hi, I am Filemon colored black

filemon.brother.sayHello()
// Hi, I am Mruczek and my brother is Filemon
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;window-binding:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;window binding&lt;/h3&gt;

&lt;p&gt;Wyżej napisałem o tym, że pominięcie &lt;em&gt;this&lt;/em&gt; spowoduje automatyczne &amp;ldquo;dopięcie&amp;rdquo; odpowiedniego kontekstu. Jednak gdy funkcja wywołana jest globalnie, to (przynajmniej w przeglądarkach) jej kontekstem będzie obiekt &lt;code&gt;window&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function openWindow() {
  console.log(this);
};

openWindow();
// Window {external: Object, chrome: Object, document: ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jednak jeśli popełnimy pewien błąd, którego konsekwencje zostały opatrzone stosownym błędem w konsoli w ECMAScript 5 (&amp;lsquo;strict&amp;rsquo; mode, w ECMAScript 3 &lt;em&gt;this&lt;/em&gt; wskazywał na &lt;em&gt;window&lt;/em&gt;, stąd to całe zamieszanie), polegający na wywołaniu konstruktora funkcji bez użycia &lt;em&gt;new&lt;/em&gt;, to otrzymamy błąd.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function someConstructor() {
  this.a = &#39;foo&#39;;
  this.b = &#39;bar&#39;;
}

var good = new someConstructor();
var bad = someConstructor();
// &amp;quot;TypeError: this is undefined&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;this-czy-nie-this-o-to-jest-pytanie:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;this czy nie this - o to jest pytanie!&lt;/h2&gt;

&lt;p&gt;Mam nadzieję, że szybki kurs z kontekstu w JS tutaj przedstawiony pomógł wam choć trochę nabrać pewności w używaniu &lt;em&gt;this&lt;/em&gt; z głową w swoich aplikacjach. Jeśli macie jakieś pytania czy uwagi z chęcią na nie odpowiem, w komentarzach czy mail/twitter.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>