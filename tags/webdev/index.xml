<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Webdev on </title>
    <link>http://ksmigiel.com/tags/webdev/</link>
    <description>Recent content in Webdev on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 30 Mar 2016 21:59:09 +0100</lastBuildDate>
    <atom:link href="http://ksmigiel.com/tags/webdev/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Kontekst i &#39;this&#39; w JavaScripcie</title>
      <link>http://ksmigiel.com/2016/03/js-this</link>
      <pubDate>Wed, 30 Mar 2016 21:59:09 +0100</pubDate>
      
      <guid>http://ksmigiel.com/2016/03/js-this</guid>
      <description>

&lt;p&gt;Słówko &lt;code&gt;this&lt;/code&gt;, mimo podobieństwa do C# czy Javy, w JavaScripcie działa trochę inaczej niż nam się może wydawać. Kontekst na jaki wskazuje &lt;em&gt;this&lt;/em&gt; może być dowolnie zmieniany, a jego nieumiejętne użycie spowodowuje wystąpienie masy błędów w naszej aplikacji. Ustrzec przed nimi można się jedynie rozumiejąc do czego owe &lt;em&gt;this&lt;/em&gt; służy i jak się z nim obchodzić. Zapraszam do lektury :)&lt;/p&gt;

&lt;h2 id=&#34;implicit-binding:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;Implicit binding&lt;/h2&gt;

&lt;p&gt;Mamy tutaj do czynienia z kontekstem zwykłych obiektów. Złota zasada w identyfikacji kontekstu to:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;this&lt;/strong&gt; to obiekt, który jest po lewej stronie kropki.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;W myśl powyższej zasady możemy stwierdzić, że kontekstem funkcji &lt;code&gt;meow()&lt;/code&gt; będzie obiekt &lt;code&gt;cat&lt;/code&gt; i tak też się dzieje.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var cat = {
  name: &#39;Filemon&#39;,
  meow: function () {
    console.log(this.name);
  }
}

cat.meow();
// Filemon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podobnie sprawa ma się w przypadku zagdnieżdżonych obiektów i ich funkcji. Najbliższy obiekt po lewej stronie (z reguły, ale o tym zaraz) jest kontekstem, w jakim zostaje wywołana dana funkcja:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var cat = {
  name: &#39;Filemon&#39;,
  brother: {
    name: &#39;Mruczek&#39;,
    meow: function () {
      console.log(this.name)
    }
  },
  meow: function () {
    console.log(this.name);
  }
}

cat.meow();
// Filemon

cat.brother.meow();
// Mruczek
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trzeba być bardzo ostrożnym jeśli chodzi o referencje do obiektów czy funkcji, gdyż takie przypisanie również powoduje zmianę kontekstu. Jest nim nadal &lt;em&gt;cat (Filemon)&lt;/em&gt;, a nie jakby można było sądzić &lt;em&gt;brother (Mruczek)&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;cat.meow = cat.brother.meow;
cat.meow();
// Filemon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Istnieją jednak sposoby na całkowie przejęcie kontroli nad tym co ma być w danej chwili &amp;ldquo;bazą&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;explicit-binding:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;Explicit binding&lt;/h2&gt;

&lt;p&gt;Oprócz operowania obiektami i zasadą &amp;ldquo;kropki&amp;rdquo; istnieją inne metody (pewne 3 funkcje), które pozwalają na zmianę kontekstu wywołania dowolnej funkcji.&lt;/p&gt;

&lt;h3 id=&#34;call:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;call()&lt;/h3&gt;

&lt;p&gt;Pozwala na wywołanie funkcji z konkretnym kontekstem przekazanym jako argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var meow = function () {
  console.log(&#39;I am a cat &#39; + this.name);
};

var filemon = {
  name: &#39;Filemon&#39;
};

var mruczek = {
  name: &#39;Mruczek&#39;
};

meow.call(filemon);
// I am a cat Filemon

meow.call(mruczek);
// I am a cat Mruczek

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bind:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;bind()&lt;/h3&gt;

&lt;p&gt;Jest to bardzo podobna funkcja do &lt;code&gt;call()&lt;/code&gt; z tą różnicą, że pozwala na &amp;ldquo;przechowanie&amp;rdquo; funkcji z nowym kontekstem w postaci zmiennej, aby móc ją na przykład przekazać dalej jako parametr funkcji.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var meow = function () {
  console.log(&#39;I am a cat &#39; + this.name);
};

var filemon = {
  name: &#39;Filemon&#39;
};

var mruczek = {
  name: &#39;Mruczek&#39;
};

var filemonMeow = meow.bind(filemon);
filemonMeow();
// I am a cat Filemon

var mruczekMeow = meow.bind(mruczek);
mruczekMeow()
// I am a cat Mruczek

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;apply:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;apply()&lt;/h3&gt;

&lt;p&gt;To taki helper składający tablicę w argumenty funkcji, który również jako parametr przyjmuje nowy obiekt, a ten stanie się &lt;em&gt;this&lt;/em&gt; w tej właśnie funkcji.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var myCats = function (cat1, cat2) {
  console.log(&#39;I am &#39; + this.name + &#39; and my cats are: &#39; + cat1 + &#39; and &#39; + cat2);
};

var me = {
  name: &#39;Krzysztof&#39;
};

var cats = [&#39;Filemon&#39;, &#39;Mruczek&#39;];

myCats.apply(me, cats);
// I am Krzysztof and my cats are: Filemon and Mruczek
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;new-binding:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;New binding&lt;/h2&gt;

&lt;p&gt;Dochodzimy w końcu do momentu, z którym większość będzie najbardziej zaznajomiona, czyli konstruktory i keyword &lt;code&gt;new&lt;/code&gt;. Sytuacja jest tu o tyle prosta, że to &lt;em&gt;new&lt;/em&gt; nadaje kontekst całego obiektu podczas jego tworzenia.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Cat(name, color) {
  this.name = name;
  this.color = color;
  this.sayHello = function () {
    console.log(&#39;Hi, I am &#39; + name + &#39; colored &#39; + color);
  };
}

var filemon = new Cat(&#39;Filemon&#39;, &#39;black&#39;);
filemon.sayHello();
// Hi, I am Filemon colored black
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zwróćcie uwagę na &lt;strong&gt;brak&lt;/strong&gt; &lt;em&gt;this&lt;/em&gt; w wywołaniu funkcji &lt;code&gt;sayHello()&lt;/code&gt;. W każdym wypadku jego użycie jest opcjonalne. Domyślnie interpreter zawsze będzie wywoływał funkcję w kontekście rozwiązanym zgodnie z zasadami, które tu dzisiaj opisałem. Dla czytelności jednak lepiej jest użyć kontekstu, aby czarno na biało było widać co z czego jest wywoływane.
Spójrzcie na przykład bardziej zawiły, gdzie gdyby nie osobna referencja do obiektu macierzystego, odwołanie się do jego własności byłoby niemożliwe.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Cat(name, color) {
  var self = this;
  
  self.name = name;
  self.color = color;
  self.sayHello = function () {
    console.log(&#39;Hi, I am &#39; + self.name + &#39; colored &#39; + self.color);
  };
  
  self.brother = {
    name: &#39;Mruczek&#39;,
    sayHello: function () {
      console.log(&#39;Hi, I am &#39; + this.name + &#39; and my brother is &#39; + self.name);
    }
  };
}

var filemon = new Cat(&#39;Filemon&#39;, &#39;black&#39;);
filemon.sayHello();
// Hi, I am Filemon colored black

filemon.brother.sayHello()
// Hi, I am Mruczek and my brother is Filemon
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;window-binding:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;window binding&lt;/h3&gt;

&lt;p&gt;Wyżej napisałem o tym, że pominięcie &lt;em&gt;this&lt;/em&gt; spowoduje automatyczne &amp;ldquo;dopięcie&amp;rdquo; odpowiedniego kontekstu. Jednak gdy funkcja wywołana jest globalnie, to (przynajmniej w przeglądarkach) jej kontekstem będzie obiekt &lt;code&gt;window&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function openWindow() {
  console.log(this);
};

openWindow();
// Window {external: Object, chrome: Object, document: ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jednak jeśli popełnimy pewien błąd, którego konsekwencje zostały opatrzone stosownym błędem w konsoli w ECMAScript 5 (&amp;lsquo;strict&amp;rsquo; mode, w ECMAScript 3 &lt;em&gt;this&lt;/em&gt; wskazywał na &lt;em&gt;window&lt;/em&gt;, stąd to całe zamieszanie), polegający na wywołaniu konstruktora funkcji bez użycia &lt;em&gt;new&lt;/em&gt;, to otrzymamy błąd.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function someConstructor() {
  this.a = &#39;foo&#39;;
  this.b = &#39;bar&#39;;
}

var good = new someConstructor();
var bad = someConstructor();
// &amp;quot;TypeError: this is undefined&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;this-czy-nie-this-o-to-jest-pytanie:aa9d6570c3e5b1909358f37548b7ef3a&#34;&gt;this czy nie this - o to jest pytanie!&lt;/h2&gt;

&lt;p&gt;Mam nadzieję, że szybki kurs z kontekstu w JS tutaj przedstawiony pomógł wam choć trochę nabrać pewności w używaniu &lt;em&gt;this&lt;/em&gt; z głową w swoich aplikacjach. Jeśli macie jakieś pytania czy uwagi z chęcią na nie odpowiem, w komentarzach czy mail/twitter.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TypeScript i pliki definicji</title>
      <link>http://ksmigiel.com/2015/05/jsblocks-dts</link>
      <pubDate>Sat, 23 May 2015 18:18:10 +0200</pubDate>
      
      <guid>http://ksmigiel.com/2015/05/jsblocks-dts</guid>
      <description>

&lt;p&gt;Dzisiaj chciałem przybliżyć kwestię plików definicji do TypeScript. Jeśli zdarzyło wam się pracować z tym językiem, to na pewno wiecie o czym mówię. Jeśli natomiast nie macie pojęcia co to jest - zapraszam do lektury!&lt;/p&gt;

&lt;h2 id=&#34;typescript-typowany-javascript:08ab5ad69c9b5eb0665d1a4bb3fb6240&#34;&gt;TypeScript - typowany JavaScript&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt; to język kompilowany do JS&amp;rsquo;a prosto od Microsoftu. W wielkim skrócie pozwala na definiowanie typów dla zmiennych, co za tym idzie, deklarowanie klas i interfejsów. Chyba nie trzeba tłumaczyć jakim ułatwieniem staje się taka możliwość w pracy każdego programisty, dla którego środowisko &amp;ldquo;js&amp;rsquo;owe&amp;rdquo; nie jest codziennością, a przychodzi ze świata &amp;ldquo;mocno typowanego&amp;rdquo; (C#, Java, cpp).&lt;/p&gt;

&lt;p&gt;Tworząc tego typu rozwiązanie Microsoft bardzo elegancko zachęca programistów C# do spróbowania swoich sił w tworzeniu aplikacji przy użyciu całego js-stack. Dzięki podobieństwom w składni i modelu OOP (w przeciwieństwie do klasycznego prototypowania w JavaScript) bardzo szybko można zacząć pisać pierwsze sensowne linie kodu, bez potrzeby spędzenia godzin na nauce składni etc. Oczywiście znajomość JS mile widziana, wręcz wskazana. Spójrzcie na różnice w TS &amp;lt;-&amp;gt; JS na przykładzie kompilacji z oficjalnej strony:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// test.ts
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &amp;quot;Hello, &amp;quot; + this.greeting;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// test.js
var Greeter = (function () {
    function Greeter(message) {
        this.greeting = message;
    }
    Greeter.prototype.greet = function () {
        return &amp;quot;Hello, &amp;quot; + this.greeting;
    };
    return Greeter;
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Powyższy kod jest chyba samowyjaśniającysię. Ta śmieszna funkcja w funkcji wywołana natychmiast to tzw. &lt;a href=&#34;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&#34;&gt;IIFE&lt;/a&gt;. Popularny wzorzec, must-known.&lt;/p&gt;

&lt;p&gt;TypeScript jest na tyle dojrzały, że nawet Google wraz z jego &lt;a href=&#34;https://angular.io/&#34;&gt;Angular 2.0&lt;/a&gt; postanowili wprowadzić natywne wsparcie dla niego!&lt;/p&gt;

&lt;h2 id=&#34;definitywnie-typowany:08ab5ad69c9b5eb0665d1a4bb3fb6240&#34;&gt;Definitywnie typowany!&lt;/h2&gt;

&lt;p&gt;Zastanawiacie się zapewne w jaki sposób można użyć TypeScript&amp;rsquo;a z istniejącymi już bibliotekami takimi jak: angular, knockout, backbone itd. Otóż istnieje &lt;strong&gt;&lt;a href=&#34;https://github.com/borisyankov/DefinitelyTyped&#34;&gt;repozytorium&lt;/a&gt;&lt;/strong&gt; definicji do przeróżnych frameworków tworzone przez społeczność open source. Sam chcąc bliżej poznać TS postanowiłem udzielić się i puściłem pull requesta z definicjami do &lt;a href=&#34;http://jsblocks.com/&#34;&gt;blocks&lt;/a&gt;. &lt;strong&gt;blocks&lt;/strong&gt; to jeden z wielu frameworków &lt;em&gt;MV*&lt;/em&gt; (dzień bez nowego frameworka js to dzień stracony) jednak zainteresował mnie ze względu na swoją prostotę i połączenie knockout+backbone (observable i modele).&lt;/p&gt;

&lt;h2 id=&#34;blocks-d-ts:08ab5ad69c9b5eb0665d1a4bb3fb6240&#34;&gt;blocks.d.ts&lt;/h2&gt;

&lt;p&gt;Deklaracja typów do istniejącego już kodu odbywa się za pomocą &lt;a href=&#34;http://www.typescriptlang.org/Handbook#modules-working-with-other-javascript-libraries&#34;&gt;Ambient External Modules&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;declare var blocks: BlocksStatic;

declare module &amp;quot;blocks&amp;quot; {
    export = blocks;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deklarując moduł w cudzysłowie &amp;ldquo;nadpisujemy&amp;rdquo; oryginalny moduł zaimportowany w pliku z aplikacją:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;/// &amp;lt;reference path=&amp;quot;blocks.d.ts&amp;quot; /&amp;gt;
import blocks = require(&#39;blocks&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jest to całkiem dobra pozycja wyjściowa do otypowania dowolnej biblioteki. Przekonacie się, że całkiem pokaźna ilość bibliotek została już przetłumaczona na TS przeglądając wspomniane wyżej repozytorium.&lt;/p&gt;

&lt;p&gt;TS automagicznie scala oryginalną bibliotekę z naszą definicją typów. Od teraz mamy piękny IntelliSense podpowiadający składnię, parametry funkcji i jej zwracaną wartość (patrz &lt;a href=&#34;http://usejsdoc.org/&#34;&gt;jsdoc&lt;/a&gt;) oraz sprawdzanie składni w locie - wszystko prawie jak w C#!&lt;/p&gt;

&lt;p&gt;Na moim &lt;a href=&#34;https://github.com/ksmigiel/DefinitelyTyped/tree/master/blocks&#34;&gt;githubie&lt;/a&gt; znajdziecie źrodła całego pliku definicji. Dokumentacja pochodzi oczywiście z oficjalnej strony autora. Co jak co, ale ta aktywność związana z opisywaniem typów nauczyła mnie TypeScript&amp;rsquo;a i jego zawiłości szybciej i przyjemniej niż nie jedna książka :)&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.typescriptlang.org/&#34;&gt;http://www.typescriptlang.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&#34;&gt;http://en.wikipedia.org/wiki/Immediately-invoked_function_expression&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://angular.io/&#34;&gt;https://angular.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/borisyankov/DefinitelyTyped&#34;&gt;https://github.com/borisyankov/DefinitelyTyped&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jsblocks.com/&#34;&gt;http://jsblocks.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.typescriptlang.org/Handbook#modules-working-with-other-javascript-libraries&#34;&gt;http://www.typescriptlang.org/Handbook#modules-working-with-other-javascript-libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://usejsdoc.org/&#34;&gt;http://usejsdoc.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ksmigiel/DefinitelyTyped/tree/master/blocks&#34;&gt;https://github.com/ksmigiel/DefinitelyTyped/tree/master/blocks&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Visual Studio Code</title>
      <link>http://ksmigiel.com/2015/05/vs-code</link>
      <pubDate>Thu, 14 May 2015 16:38:00 +0100</pubDate>
      
      <guid>http://ksmigiel.com/2015/05/vs-code</guid>
      <description>

&lt;p&gt;Microsoft na tegorocznej konferencji &lt;strong&gt;//build/&lt;/strong&gt; zaskoczył nas paroma nowinkami. Jeśli nie jesteście na bieżąco polecam zerknąć na &lt;a href=&#34;http://blogs.technet.com/b/uktechnet/archive/2015/04/30/announcements-from-build-2015.aspx&#34;&gt;podsumowanie&lt;/a&gt;. Każdy znajdzie coś dla siebie.&lt;/p&gt;

&lt;h2 id=&#34;vs-code:6d2be7abc42720062e9271b30ee0bbbf&#34;&gt;VS Code&lt;/h2&gt;

&lt;p&gt;Mnie osobiście najbardziej spodobał się edytor &lt;a href=&#34;http://code.visualstudio.com&#34;&gt;&lt;strong&gt;Visual Studio Code&lt;/strong&gt;&lt;/a&gt;, czyli taki Sublime Text w Microsoftowym wydaniu. W całości oparty na node.js i edytorze &lt;a href=&#34;https://atom.io/&#34;&gt;&lt;strong&gt;Atom&lt;/strong&gt;&lt;/a&gt; od GitHuba, a konkretnie na bibliotece &lt;a href=&#34;https://github.com/atom/electron&#34;&gt;&lt;strong&gt;Electron&lt;/strong&gt;&lt;/a&gt; umożliwiającej pisanie cross-platformowych desktopowych aplikacji w JS/HTML/CSS. Główne cechy wyróżniające Code na tle innych edytorów to m.in.:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cross-platformowość (sprawdzałem i faktycznie tak jest! :) )&lt;/li&gt;
&lt;li&gt;debugging aplikacji napisanych w node.js (ASP.NET 5 w przygotowaniu)&lt;/li&gt;
&lt;li&gt;tasks - integracja z popularnymi narzędziami do automatyzacji buildów, testowania i deployowania (Make, Ant, Gulp, Jake, Rake, MSBuild)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://schemastore.org/json/&#34;&gt;JSON schema&lt;/a&gt; - code-completion w plikach konfiguracyjnych JSON&lt;/li&gt;
&lt;li&gt;wsparcie TypeScript (code-completion, &lt;em&gt;&amp;ldquo;go to definition&amp;rdquo;&lt;/em&gt; etc.)&lt;/li&gt;
&lt;li&gt;fuzzy-search - przeszukiwanie plików projektu oraz ustawień edytora (&lt;em&gt;Ctrl+E&lt;/em&gt; i &lt;em&gt;Ctrl-Shift-P&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;parsowanie i podgląd &lt;a href=&#34;http://daringfireball.net/projects/markdown/&#34;&gt;Markdown&lt;/a&gt; w locie - w ten sposób powstaje ten post :)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;W obecnej wersji brakuje mi klawiszologii VIM&amp;rsquo;a (jak się człowiek raz przyzwyczai to potem wszystkie inne skróty klawiszowe wydają się bezsensowne) oraz możliwości tworzenia własnych snippetów, co mam nadzieję zostanie dodane w nadchodzących wydaniach.&lt;/p&gt;

&lt;p&gt;Polecam zapoznać się z tym edytorem. Pomimo wersji &lt;em&gt;Preview&lt;/em&gt; posiada masę fajnych funkcjonalności.&lt;/p&gt;

&lt;h2 id=&#34;monaco:6d2be7abc42720062e9271b30ee0bbbf&#34;&gt;Monaco?&lt;/h2&gt;

&lt;p&gt;Jeśli po ściągnięciu Code&amp;rsquo;a masz wrażenie graniczące z pewnością, że gdzieś już to widziałeś to masz całkowitą rację! Microsoft do jego budowy oprócz wspomnianego Atoma wykorzystał &lt;a href=&#34;http://blogs.msdn.com/b/monaco/archive/2014/06/26/how-to-access-visual-studio-online-monaco-from-the-new-azure-portal.aspx&#34;&gt;&lt;strong&gt;Visual Studio Monaco&lt;/strong&gt;&lt;/a&gt;, które jako rozszerzenie można doinstalować w panelu &lt;strong&gt;Azure&lt;/strong&gt; do dowolnej aplikacji na nim hostowanej. Monaco to webowy edytor w &lt;em&gt;&amp;ldquo;chmurze&amp;rdquo;&lt;/em&gt; zintegrowany z wierszem poleceń (dostęp do &lt;code&gt;node&lt;/code&gt; i &lt;code&gt;npm&lt;/code&gt;). Preinstalowany node.js pozwala na hostowanie aplikacji webowych przy użyciu &lt;a href=&#34;https://github.com/tjanczuk/iisnode&#34;&gt;iisnode&lt;/a&gt;. Może posłużyć jako pomoc podczas szybkiej edycji pliku na serwerze albo jako IDE w chmurze :)&lt;/p&gt;

&lt;p&gt;Od jakiegoś czasu na blogu MSDN zaprzestano informować o jakichkolwiek newsach związanych z rozwojem Monaco. Jednak po konferencji &lt;strong&gt;//build/&lt;/strong&gt; nie mam wątpliwości, że Microsoft szykował się na premierę swojego nowego edytora i tak na prawdę tworzył dwa narzędzia równocześnie (pod spodem są te same bebechy: node.js i WebKit).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;protip: naciśnij F12 w edytorze &lt;strong&gt;Code&lt;/strong&gt; i wszystko jasne!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jestem ciekawy czy w przyszłości te dwa projekty staną się jednym tworem.&lt;/p&gt;

&lt;h2 id=&#34;changes-changes-everywhere:6d2be7abc42720062e9271b30ee0bbbf&#34;&gt;Changes, changes everywhere!&lt;/h2&gt;

&lt;p&gt;Muszę przyznać, że lubię ten &amp;ldquo;nowy Microsoft&amp;rdquo;. Edge, ASP.NET vNext, DNX, Code czy rozwój PowerShella sprawiają, że Windows i jego cały ekosystem stają się bardziej &amp;ldquo;developer-friendly&amp;rdquo;. To chyba dobrze, że chcą przyciągnąc do platformy developerów - w końcu to oni ją tworzą.&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blogs.technet.com/b/uktechnet/archive/2015/04/30/announcements-from-build-2015.aspx&#34;&gt;http://blogs.technet.com/b/uktechnet/archive/2015/04/30/announcements-from-build-2015.aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code.visualstudio.com&#34;&gt;http://code.visualstudio.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atom.io/&#34;&gt;https://atom.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/atom/electron&#34;&gt;https://github.com/atom/electron&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://schemastore.org/json/&#34;&gt;http://schemastore.org/json/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://daringfireball.net/projects/markdown/&#34;&gt;http://daringfireball.net/projects/markdown/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blogs.msdn.com/b/monaco/archive/2014/06/26/how-to-access-visual-studio-online-monaco-from-the-new-azure-portal.aspx&#34;&gt;http://blogs.msdn.com/b/monaco/archive/2014/06/26/how-to-access-visual-studio-online-monaco-from-the-new-azure-portal.aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tjanczuk/iisnode&#34;&gt;https://github.com/tjanczuk/iisnode&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>